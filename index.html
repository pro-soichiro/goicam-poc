<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ゴイキャン - 語彙力トレーニング</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
          "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
        line-height: 1.6;
        color: #333;
        background: #f5f5f5;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        background: #2c3e50;
        color: white;
        padding: 1rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h1 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .stats {
        display: flex;
        gap: 1rem;
        font-size: 0.9rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .stat-item {
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }
      .combo {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        padding: 0.3rem 0.8rem;
        border-radius: 20px;
        font-weight: bold;
        animation: pulse 0.5s ease;
        box-shadow: 0 2px 8px rgba(243, 156, 18, 0.4);
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
        }
      }
      .score-display {
        font-size: 1.2rem;
        font-weight: bold;
        color: #f39c12;
      }
      main {
        flex: 1;
        max-width: 600px;
        width: 100%;
        margin: 0 auto;
        padding: 1.5rem;
      }
      .card {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 1rem;
      }
      .term {
        font-size: 1.8rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 1.5rem;
        color: #2c3e50;
      }
      .choices {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }
      .choice-btn {
        background: white;
        border: 2px solid #3498db;
        color: #3498db;
        padding: 1rem;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        text-align: left;
        transition: all 0.2s;
        position: relative;
      }
      .choice-btn:hover:not(:disabled) {
        background: #3498db;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
      }
      .choice-btn:focus {
        outline: 3px solid #f39c12;
        outline-offset: 2px;
      }
      .choice-btn:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .choice-btn.correct {
        background: #27ae60;
        color: white;
        border-color: #27ae60;
      }
      .choice-btn.incorrect {
        background: #e74c3c;
        color: white;
        border-color: #e74c3c;
      }
      .choice-num {
        display: inline-block;
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 50%;
        background: #ecf0f1;
        color: #2c3e50;
        text-align: center;
        line-height: 1.5rem;
        font-weight: bold;
        margin-right: 0.5rem;
        font-size: 0.9rem;
      }
      .choice-btn:hover:not(:disabled) .choice-num {
        background: rgba(255, 255, 255, 0.3);
        color: white;
      }
      .feedback {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 6px;
        display: none;
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .feedback.show {
        display: block;
      }
      .feedback.correct {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        border: 2px solid #27ae60;
        color: #155724;
      }
      .feedback.incorrect {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        border: 2px solid #e74c3c;
        color: #721c24;
      }
      .feedback-title {
        font-weight: bold;
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
        animation: bounce 0.5s ease;
      }
      @keyframes bounce {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      .example {
        margin: 0.8rem 0;
        padding: 0.8rem;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 4px;
        font-size: 0.95rem;
        line-height: 1.6;
        font-style: italic;
      }
      .next-btn {
        background: #27ae60;
        color: white;
        border: none;
        padding: 0.8rem 2rem;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        margin-top: 1rem;
        width: 100%;
        transition: all 0.2s;
      }
      .next-btn:hover {
        background: #229954;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
      }
      .next-btn:focus {
        outline: 3px solid #f39c12;
        outline-offset: 2px;
      }
      .start-screen {
        text-align: center;
        padding: 2rem 0;
      }
      .start-screen h2 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
        color: #2c3e50;
      }
      .daily-theme {
        display: inline-block;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        margin-bottom: 1rem;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }
      .start-screen p {
        color: #666;
        margin-bottom: 2rem;
        line-height: 1.8;
        font-size: 0.95rem;
      }
      .start-btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 1rem 3rem;
        border-radius: 6px;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s;
      }
      .start-btn:hover {
        background: #2980b9;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
      }
      .start-btn:focus {
        outline: 3px solid #f39c12;
        outline-offset: 2px;
      }
      .result-screen {
        text-align: center;
        padding: 2rem 0;
      }
      .result-screen h2 {
        font-size: 1.8rem;
        margin-bottom: 1.5rem;
        color: #2c3e50;
      }
      .result-stats {
        background: #ecf0f1;
        padding: 1.5rem;
        border-radius: 8px;
        margin-bottom: 2rem;
      }
      .result-stat {
        font-size: 1.2rem;
        margin: 0.8rem 0;
        color: #2c3e50;
      }
      .result-stat strong {
        color: #27ae60;
        font-size: 1.5rem;
      }
      .result-badge {
        display: inline-block;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        padding: 0.8rem 1.5rem;
        border-radius: 25px;
        margin: 1rem 0;
        font-size: 1.3rem;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        animation: bounce 0.6s ease;
      }
      .continue-tomorrow {
        margin-top: 1rem;
        padding: 1rem;
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 8px;
        color: #856404;
        font-size: 0.95rem;
      }
      .reset-btn {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.6rem 1.5rem;
        border-radius: 6px;
        font-size: 0.9rem;
        cursor: pointer;
        margin-top: 1rem;
        transition: all 0.2s;
      }
      .reset-btn:hover {
        background: #c0392b;
        transform: translateY(-1px);
      }
      .reset-btn:focus {
        outline: 3px solid #f39c12;
        outline-offset: 2px;
      }
      .review-toggle {
        margin-top: 1.5rem;
        text-align: center;
        cursor: pointer;
        color: #7f8c8d;
        font-size: 0.9rem;
        padding: 0.5rem;
        transition: color 0.2s;
      }
      .review-toggle:hover {
        color: #34495e;
      }
      .review-details {
        margin-top: 1rem;
        padding: 1.5rem;
        background: #f8f9fa;
        border-radius: 8px;
        text-align: left;
        max-height: 400px;
        overflow-y: auto;
      }
      .review-item {
        padding: 1rem;
        margin-bottom: 0.8rem;
        background: white;
        border-radius: 6px;
        border-left: 4px solid #ddd;
      }
      .review-item.correct {
        border-left-color: #27ae60;
      }
      .review-item.incorrect {
        border-left-color: #e74c3c;
      }
      .review-term {
        font-weight: bold;
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        color: #2c3e50;
      }
      .review-answer {
        font-size: 0.95rem;
        margin: 0.3rem 0;
        color: #555;
      }
      .review-result {
        display: inline-block;
        padding: 0.2rem 0.6rem;
        border-radius: 12px;
        font-size: 0.85rem;
        font-weight: bold;
        margin-left: 0.5rem;
      }
      .review-result.correct {
        background: #d4edda;
        color: #155724;
      }
      .review-result.incorrect {
        background: #f8d7da;
        color: #721c24;
      }
      .hidden {
        display: none;
      }
      .timer-bar {
        height: 4px;
        background: #ecf0f1;
        border-radius: 2px;
        overflow: hidden;
        margin-bottom: 1rem;
      }
      .timer-progress {
        height: 100%;
        background: linear-gradient(90deg, #3498db 0%, #2ecc71 100%);
        transition: width 10s linear;
        width: 100%;
      }
      footer {
        background: white;
        padding: 1rem;
        text-align: center;
        border-top: 1px solid #ddd;
        font-size: 0.9rem;
        color: #666;
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      @media (max-width: 480px) {
        h1 {
          font-size: 1.2rem;
        }
        .term {
          font-size: 1.5rem;
        }
        .choice-btn {
          font-size: 0.95rem;
          padding: 0.8rem;
        }
        .start-btn {
          padding: 0.8rem 2rem;
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>📚 ゴイキャン</h1>
      <div class="stats">
        <div class="stat-item">
          🎯 スコア: <span class="score-display" id="score">0</span>
        </div>
        <div class="stat-item combo hidden" id="combo-display">
          🔥 <span id="combo">0</span> COMBO!
        </div>
        <div class="stat-item">🔥 <strong id="streak">0</strong>日</div>
      </div>
    </header>

    <main>
      <div class="card" id="start-screen">
        <div class="start-screen">
          <div class="daily-theme" id="daily-theme">📖 今日のお題</div>
          <h2>5問クリアで達成！</h2>
          <p>制限時間10秒、連続正解でボーナス<br />サクッと1分で完走しよう</p>
          <div
            style="
              display: flex;
              gap: 1rem;
              margin-top: 1.5rem;
              flex-wrap: wrap;
              justify-content: center;
            "
          >
            <button
              class="start-btn"
              onclick="startQuiz('mixed')"
              style="
                flex: 1;
                min-width: 200px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              "
              onmouseover="this.style.opacity='0.9'"
              onmouseout="this.style.opacity='1'"
            >
              おまかせ（推奨）
            </button>
          </div>
          <div
            style="
              display: flex;
              gap: 0.5rem;
              margin-top: 0.8rem;
              flex-wrap: wrap;
              justify-content: center;
            "
          >
            <button
              class="start-btn"
              onclick="startQuiz('meaning')"
              style="
                flex: 1;
                min-width: 140px;
                font-size: 0.9rem;
                padding: 0.7rem 1.5rem;
              "
            >
              意味理解型
            </button>
            <button
              class="start-btn"
              onclick="startQuiz('recall')"
              style="
                flex: 1;
                min-width: 140px;
                font-size: 0.9rem;
                padding: 0.7rem 1.5rem;
                background: #9b59b6;
              "
              onmouseover="this.style.background='#8e44ad'"
              onmouseout="this.style.background='#9b59b6'"
            >
              語句想起型
            </button>
          </div>
        </div>
      </div>

      <div class="card hidden" id="quiz-screen">
        <div class="timer-bar">
          <div class="timer-progress" id="timer-progress"></div>
        </div>
        <div class="term" id="term"></div>
        <div class="choices" id="choices"></div>
        <div
          class="feedback"
          id="feedback"
          role="status"
          aria-live="polite"
          aria-atomic="true"
        ></div>
      </div>

      <div class="card hidden" id="result-screen">
        <div class="result-screen">
          <h2>🎉 クリア！</h2>
          <div class="result-badge" id="result-badge">🏆 語彙マスター</div>
          <div class="result-stats">
            <div class="result-stat">
              獲得スコア: <strong id="result-score">0</strong>pt
            </div>
            <div class="result-stat">
              最大コンボ: <strong id="result-max-combo">0</strong>連続
            </div>
          </div>
          <div class="continue-tomorrow">
            ⏰ 明日の新しいお題は 0:00 に更新！<br />
            続きはまた明日お楽しみに✨
          </div>
          <div class="review-toggle" onclick="toggleReview()">
            <span id="review-toggle-text">▼ 回答を確認する</span>
          </div>
          <div class="review-details hidden" id="review-details"></div>
        </div>
      </div>
    </main>

    <footer id="footer">
      復習準備中...
      <div style="margin-top: 1rem">
        <button class="reset-btn" onclick="resetAllData()">
          データをリセット
        </button>
      </div>
    </footer>

    <script>
      // 初期問題データ
      const QUESTIONS = [
        {
          id: 1,
          term: "是非を問う",
          correct: "物事の正しいか正しくないかを判断する",
          incorrect: [
            "絶対にやり遂げようと強く求める",
            "全力を尽くして取り組む",
            "相手に熱心に依頼する",
          ],
          recallIncorrect: ["応酬する", "成就する", "言及する"],
          explanation: "是か非か＝正しいか正しくないかを判断する意。",
          example: "例：会議で新方針の是非を問う場面となった",
        },
        {
          id: 2,
          term: "監督",
          correct: "指導・取り締まりをして見守ること",
          incorrect: [
            "実際に現場で作業すること",
            "上位者に相談して判断を仰ぐこと",
            "規則を作り制度化すること",
          ],
          recallIncorrect: ["管理する", "調整する", "統制する"],
          explanation: "指導・取り締まりの立場から見守ること。",
          example: "例：工事現場を監督する責任者が配置された",
        },
        {
          id: 3,
          term: "ステルスマーケティング",
          correct: "広告と気づかれない形で商品を宣伝すること",
          incorrect: [
            "新しい販売戦略を開発すること",
            "消費者の購買傾向を分析すること",
            "自然に売れる仕組みを作ること",
          ],
          recallIncorrect: [
            "バイラルマーケティング",
            "ダイレクトマーケティング",
            "コンテンツマーケティング",
          ],
          explanation: "広告表示をせず宣伝する手法。略称「ステマ」。",
          example: "例：有名人が自然に商品を紹介してステマ疑惑が浮上",
        },
        {
          id: 4,
          term: "バツが悪い",
          correct: "気まずく、居心地が悪い",
          incorrect: [
            "体調が悪く、調子が出ない",
            "失敗して大きな損害を受ける",
            "判断を誤り、結果が不利になる",
          ],
          recallIncorrect: ["気が重い", "面目ない", "心苦しい"],
          explanation: "その場に居づらい感じの「気まずさ」。",
          example: "例：偶然元カレに会ってバツが悪い思いをした",
        },
        {
          id: 5,
          term: "揶揄する",
          correct: "からかうように言う",
          incorrect: [
            "やさしく助言する",
            "遠回しに皮肉を述べる",
            "さりげなく示唆する",
          ],
          recallIncorrect: ["批評する", "嘲笑する", "非難する"],
          explanation: "からかい・なぶりを含む言い方。",
          example: "例：彼の失敗を揶揄するような発言は控えるべきだ",
        },
        {
          id: 6,
          term: "破談になる",
          correct: "まとまりかけていた話が取りやめになる",
          incorrect: [
            "談話が激しくなって口論になる",
            "相手と縁を切って絶交する",
            "嘘の話で人をだます",
          ],
          recallIncorrect: ["決裂する", "頓挫する", "白紙に戻る"],
          explanation: "まとまりかけていた縁談や商談などが取りやめになること。",
          example: "例：条件が合わず、結婚の話は破談になった",
        },
        {
          id: 7,
          term: "示唆する",
          correct: "それとなくほのめかす",
          incorrect: [
            "強く命令して行動を促す",
            "根拠を示して説得する",
            "詳細に説明して理解させる",
          ],
          recallIncorrect: ["暗示する", "陳述する", "応答する"],
          explanation: "直接的に言わず、それとなく気づかせること。",
          example: "例：上司は異動の可能性を示唆するような発言をした",
        },
        {
          id: 8,
          term: "如実に",
          correct: "ありのままに、実際のとおりに",
          incorrect: [
            "おおげさに誇張して",
            "わかりやすく簡略化して",
            "一部だけを強調して",
          ],
          recallIncorrect: ["悠然と", "抽象的に", "詳細に"],
          explanation: "事実そのまま、ありのままの意。",
          example: "例：データが業績悪化の実態を如実に示している",
        },
        {
          id: 9,
          term: "重宝する",
          correct: "便利で役に立つとして大切に使う",
          incorrect: [
            "高価で手に入りにくい",
            "長く保管して滅多に使わない",
            "他人に貸して価値を上げる",
          ],
          recallIncorrect: ["尊重する", "慎重に扱う", "専念する"],
          explanation: "便利で役立つものとして大事に使うこと。",
          example: "例：このツールは作業効率化に重宝している",
        },
        {
          id: 10,
          term: "不問に付す",
          correct: "問題にせず、咎めないことにする",
          incorrect: [
            "詳しく調べて処罰する",
            "あいまいなまま放置する",
            "一時的に中止して再検討する",
          ],
          recallIncorrect: ["断罪する", "保留にする", "質疑する"],
          explanation: "過ちや責任を問わず、処罰しないこと。",
          example: "例：初犯ということで今回は不問に付すことにした",
        },
      ];

      // デイリーテーマ候補
      const DAILY_THEMES = [
        "📖 ビジネス基礎語",
        "🎯 誤用しやすい言葉",
        "✨ 教養ワード",
        "💼 敬語マスター",
        "🔥 今週の必修語",
      ];

      // 間隔反復の間隔設定（日数）
      const INTERVALS = [1, 2, 4, 7, 14, 30];

      // グローバルステート
      let currentQuestion = null;
      let currentChoices = [];
      let answered = false;
      let progress = null;
      let quizSession = null; // 現在のクイズセッション
      let timerInterval = null; // タイマーインターバル
      let autoNextTimeout = null; // 自動遷移タイマー
      let answerHistory = []; // 回答履歴
      let quizMode = "meaning"; // 'meaning' or 'recall'

      // 初期化
      function init() {
        loadProgress();
        updateStats();
        setupKeyboardShortcuts();
        showScreen("start");
        setDailyTheme();
      }

      // デイリーテーマを設定
      function setDailyTheme() {
        const today = new Date();
        const dayIndex = today.getDay(); // 0-6
        const theme = DAILY_THEMES[dayIndex % DAILY_THEMES.length];
        document.getElementById("daily-theme").textContent = theme;
      }

      // 画面切り替え
      function showScreen(screenName) {
        document.getElementById("start-screen").classList.add("hidden");
        document.getElementById("quiz-screen").classList.add("hidden");
        document.getElementById("result-screen").classList.add("hidden");

        document
          .getElementById(`${screenName}-screen`)
          .classList.remove("hidden");
      }

      // クイズ開始
      function startQuiz(mode = "meaning") {
        quizMode = mode;
        quizSession = {
          questions: [...QUESTIONS].sort(() => Math.random() - 0.5).slice(0, 5), // シャッフルして5問だけ選択
          currentIndex: 0,
          correctCount: 0,
          score: 0,
          combo: 0,
          maxCombo: 0,
        };
        answerHistory = []; // 回答履歴をリセット
        showScreen("quiz");
        showNextQuestion();
      }

      // スコア更新
      function updateScore() {
        document.getElementById("score").textContent = quizSession.score;

        // コンボ表示更新
        const comboDisplay = document.getElementById("combo-display");
        const comboText = document.getElementById("combo");

        if (quizSession.combo >= 2) {
          comboDisplay.classList.remove("hidden");
          comboText.textContent = quizSession.combo;
          // アニメーションをリセット
          comboDisplay.style.animation = "none";
          setTimeout(() => {
            comboDisplay.style.animation = "";
          }, 10);
        } else {
          comboDisplay.classList.add("hidden");
        }
      }

      // localStorageからプログレスを読み込み
      function loadProgress() {
        const saved = localStorage.getItem("vocabQuizProgress");
        if (saved) {
          progress = JSON.parse(saved);
          updateStreak();
        } else {
          // 初回起動時の初期化
          progress = {
            streak: 0,
            lastPlayedDate: getTodayString(),
            todayCount: 0,
            totalCorrect: 0,
            words: {},
          };
          QUESTIONS.forEach((q) => {
            progress.words[q.id] = {
              stage: 0,
              nextDue: getTodayString(),
              correct: 0,
              wrong: 0,
              mode: "meaning", // 'meaning' or 'recall'
            };
          });
          saveProgress();
        }
      }

      // プログレスを保存
      function saveProgress() {
        localStorage.setItem("vocabQuizProgress", JSON.stringify(progress));
      }

      // 今日の日付を文字列で取得（YYYY-MM-DD）
      function getTodayString() {
        const today = new Date();
        return today.toISOString().split("T")[0];
      }

      // 日付の差分を計算（日数）
      function daysDiff(dateStr1, dateStr2) {
        const d1 = new Date(dateStr1);
        const d2 = new Date(dateStr2);
        return Math.floor((d2 - d1) / (1000 * 60 * 60 * 24));
      }

      // 連続日数を更新
      function updateStreak() {
        const today = getTodayString();
        const diff = daysDiff(progress.lastPlayedDate, today);

        if (diff === 0) {
          // 同日内
          return;
        } else if (diff === 1) {
          // 連続
          progress.streak++;
        } else if (diff > 1) {
          // 途切れた
          progress.streak = 1;
        }

        progress.lastPlayedDate = today;
        progress.todayCount = 0;
      }

      // 統計表示を更新
      function updateStats() {
        document.getElementById("streak").textContent = progress.streak;
      }

      // タイマー開始
      function startTimer() {
        // 既存のタイマーをすべてクリア
        clearTimeout(timerInterval);
        clearTimeout(autoNextTimeout);

        const timerBar = document.getElementById("timer-progress");
        timerBar.style.transition = "none";
        timerBar.style.width = "100%";

        setTimeout(() => {
          timerBar.style.transition = "width 20s linear";
          timerBar.style.width = "0%";
        }, 50);

        // 20秒後に自動で不正解扱い
        timerInterval = setTimeout(() => {
          if (!answered) {
            autoIncorrect();
          }
        }, 20000);
      }

      // 自動不正解
      function autoIncorrect() {
        if (answered) return; // 既に回答済みなら何もしない
        answered = true;
        quizSession.combo = 0;
        updateScore();

        const feedbackEl = document.getElementById("feedback");
        feedbackEl.className = "feedback show incorrect";
        feedbackEl.innerHTML = `
        <div class="feedback-title">⏰ タイムアップ！</div>
        <div class="example">${currentQuestion.example}</div>
        <button class="next-btn" onclick="proceedToNext()">次へ →</button>
      `;

        // 回答履歴に記録
        answerHistory.push({
          question: currentQuestion,
          userAnswer: null,
          isCorrect: false,
          isTimeout: true,
        });

        updateProgress(false);
        saveProgress();
        quizSession.currentIndex++;

        autoNextTimeout = setTimeout(() => {
          showNextQuestion();
        }, 3000);
      }

      // 問題を表示
      function showNextQuestion() {
        // クイズが終了しているか確認
        if (quizSession.currentIndex >= quizSession.questions.length) {
          showResult();
          return;
        }

        answered = false;
        currentQuestion = quizSession.questions[quizSession.currentIndex];

        // 問題ごとの習熟度に応じて形式を決定（混合モードの場合）
        let currentMode = quizMode;
        if (quizMode === "mixed") {
          const wordProgress = progress.words[currentQuestion.id];
          // 既存データにmodeがない場合は追加
          if (!wordProgress.mode) {
            wordProgress.mode = "meaning";
          }
          currentMode = wordProgress.mode;
        }

        // 選択肢をシャッフル（形式に応じて選択肢を切り替え）
        if (currentMode === "recall") {
          // 語句想起型：意味を表示、語句を選択肢に
          currentChoices = [
            { text: currentQuestion.term, isCorrect: true },
            ...currentQuestion.recallIncorrect.map((text) => ({
              text,
              isCorrect: false,
            })),
          ].sort(() => Math.random() - 0.5);
        } else {
          // 意味理解型：語句を表示、意味を選択肢に
          currentChoices = [
            { text: currentQuestion.correct, isCorrect: true },
            ...currentQuestion.incorrect.map((text) => ({
              text,
              isCorrect: false,
            })),
          ].sort(() => Math.random() - 0.5);
        }

        // 現在のモードを保存（レンダリングで使用）
        quizSession.currentQuestionMode = currentMode;

        renderQuestion();
        updateFooter();
        startTimer();
      }

      // 結果画面を表示
      function showResult() {
        // すべてのタイマーをクリア
        clearTimeout(timerInterval);
        clearTimeout(autoNextTimeout);

        document.getElementById("result-score").textContent = quizSession.score;
        document.getElementById("result-max-combo").textContent =
          quizSession.maxCombo;

        // バッジを決定
        const rate =
          (quizSession.correctCount / quizSession.questions.length) * 100;
        let badge = "🎉 挑戦者";
        if (rate === 100) badge = "🏆 パーフェクト！";
        else if (rate >= 80) badge = "🌟 語彙マスター";
        else if (rate >= 60) badge = "✨ 優秀";

        document.getElementById("result-badge").textContent = badge;
        showScreen("result");
      }

      // 問題をレンダリング
      function renderQuestion() {
        const currentMode = quizSession.currentQuestionMode || quizMode;

        // モード切り替えの通知を表示
        const termEl = document.getElementById("term");
        if (quizMode === "mixed" && currentMode === "recall") {
          // 語句想起型に切り替わった時の通知を一時表示
          termEl.innerHTML = `<div style="color: #9b59b6; font-size: 1rem; margin-bottom: 1rem;">🧩 意味から語句を選ぶモードです</div>${currentQuestion.correct}`;
        } else if (quizMode === "mixed" && currentMode === "meaning") {
          termEl.textContent = currentQuestion.term;
        } else if (currentMode === "recall") {
          // 語句想起型：意味を表示
          termEl.textContent = currentQuestion.correct;
        } else {
          // 意味理解型：語句を表示
          termEl.textContent = currentQuestion.term;
        }

        const choicesEl = document.getElementById("choices");
        choicesEl.innerHTML = "";

        currentChoices.forEach((choice, index) => {
          const btn = document.createElement("button");
          btn.className = "choice-btn";
          btn.innerHTML = `<span class="choice-num">${index + 1}</span>${
            choice.text
          }`;
          btn.onclick = () => checkAnswer(index);
          btn.setAttribute("data-index", index);
          choicesEl.appendChild(btn);
        });

        const feedbackEl = document.getElementById("feedback");
        feedbackEl.className = "feedback";
        feedbackEl.innerHTML = "";
      }

      // 回答をチェック
      function checkAnswer(selectedIndex) {
        if (answered) return;
        answered = true;

        // すべてのタイマーをクリア
        clearTimeout(timerInterval);
        clearTimeout(autoNextTimeout);

        const selectedChoice = currentChoices[selectedIndex];
        const isCorrect = selectedChoice.isCorrect;

        // 回答履歴に記録
        answerHistory.push({
          question: currentQuestion,
          userAnswer: selectedChoice.text,
          correctAnswer: currentQuestion.correct,
          isCorrect: isCorrect,
          isTimeout: false,
        });

        // スコア計算
        if (isCorrect) {
          quizSession.correctCount++;
          quizSession.combo++;
          quizSession.maxCombo = Math.max(
            quizSession.maxCombo,
            quizSession.combo
          );

          // コンボボーナス込みのスコア
          const baseScore = 100;
          const comboBonus = (quizSession.combo - 1) * 50;
          quizSession.score += baseScore + comboBonus;
        } else {
          quizSession.combo = 0;
        }

        updateScore();

        // ボタンの状態を更新
        const buttons = document.querySelectorAll(".choice-btn");
        buttons.forEach((btn, index) => {
          btn.disabled = true;
          if (currentChoices[index].isCorrect) {
            btn.classList.add("correct");
          } else if (index === selectedIndex && !isCorrect) {
            btn.classList.add("incorrect");
          }
        });

        // フィードバック表示
        showFeedback(isCorrect);

        // プログレス更新
        updateProgress(isCorrect);
        updateStats();
        saveProgress();

        // 問題インデックスを進める
        quizSession.currentIndex++;

        // 自動で次へ（0.7秒後）
        autoNextTimeout = setTimeout(() => {
          showNextQuestion();
        }, 3000);
      }

      // フィードバックを表示
      function showFeedback(isCorrect) {
        const feedbackEl = document.getElementById("feedback");
        feedbackEl.className = `feedback show ${
          isCorrect ? "correct" : "incorrect"
        }`;

        let title = isCorrect ? "✅ 正解！" : "❌ 惜しい！";

        // コンボボーナス表示
        let comboText = "";
        if (isCorrect && quizSession.combo >= 2) {
          const bonus = (quizSession.combo - 1) * 50;
          comboText = `<div style="color: #f39c12; font-weight: bold; margin-top: 0.5rem;">🔥 ${quizSession.combo}連続！ +${bonus}pt</div>`;
        }

        feedbackEl.innerHTML = `
        <div class="feedback-title">${title}</div>
        ${comboText}
        <div class="example">${currentQuestion.example}</div>
        <button class="next-btn" onclick="proceedToNext()">次へ →</button>
      `;
      }

      // プログレスを更新（間隔反復）
      function updateProgress(isCorrect) {
        const wordProgress = progress.words[currentQuestion.id];

        if (isCorrect) {
          wordProgress.correct++;
          progress.totalCorrect++;
          progress.todayCount++;

          // ステージを進める
          wordProgress.stage = Math.min(
            wordProgress.stage + 1,
            INTERVALS.length - 1
          );
        } else {
          wordProgress.wrong++;
          progress.todayCount++;

          // ステージを戻す
          wordProgress.stage = Math.max(wordProgress.stage - 1, 0);
        }

        // 習熟度に応じてモードを自動切り替え（混合モードの場合のみ）
        if (quizMode === "mixed") {
          const totalAttempts = wordProgress.correct + wordProgress.wrong;
          const accuracy =
            totalAttempts > 0 ? wordProgress.correct / totalAttempts : 0;

          // 既存データにmodeがない場合は追加
          if (!wordProgress.mode) {
            wordProgress.mode = "meaning";
          }

          // ステージ3以上 または 正答率80%以上で語句想起型に昇格
          if (
            wordProgress.mode === "meaning" &&
            (wordProgress.stage >= 3 || accuracy >= 0.8) &&
            totalAttempts >= 3
          ) {
            wordProgress.mode = "recall";
          }

          // 語句想起型で正答率が60%未満に落ちたら意味理解型に戻す
          if (
            wordProgress.mode === "recall" &&
            accuracy < 0.6 &&
            totalAttempts >= 3
          ) {
            wordProgress.mode = "meaning";
          }
        }

        // 次回復習日を計算
        const interval = INTERVALS[wordProgress.stage];
        const nextDue = new Date();
        nextDue.setDate(nextDue.getDate() + interval);
        wordProgress.nextDue = nextDue.toISOString().split("T")[0];
      }

      // フッター更新
      function updateFooter() {
        const footerEl = document.getElementById("footer");

        // クイズセッション中は進捗を表示
        if (
          quizSession &&
          quizSession.currentIndex < quizSession.questions.length
        ) {
          const current = quizSession.currentIndex + 1;
          const total = quizSession.questions.length;
          footerEl.textContent = `📝 進捗: ${current} / ${total}問目`;
        } else {
          const today = getTodayString();
          const dueCount = QUESTIONS.filter((q) => {
            return progress.words[q.id].nextDue <= today;
          }).length;

          if (dueCount > 0) {
            footerEl.textContent = `📝 今日の復習: ${dueCount}問`;
          } else {
            footerEl.textContent = "🎉 今日の復習は完了です！";
          }
        }
      }

      // キーボードショートカット
      function setupKeyboardShortcuts() {
        document.addEventListener("keydown", (e) => {
          // クイズ画面でのみ動作
          const quizScreen = document.getElementById("quiz-screen");
          if (quizScreen.classList.contains("hidden")) return;

          if (!answered && ["1", "2", "3", "4"].includes(e.key)) {
            const index = parseInt(e.key) - 1;
            if (index < currentChoices.length) {
              checkAnswer(index);
            }
          }
        });
      }

      // 回答確認をトグル
      function toggleReview() {
        const reviewDetails = document.getElementById("review-details");
        const toggleText = document.getElementById("review-toggle-text");

        if (reviewDetails.classList.contains("hidden")) {
          // 表示する
          reviewDetails.classList.remove("hidden");
          toggleText.textContent = "▲ 回答を閉じる";
          renderReviewDetails();
        } else {
          // 非表示にする
          reviewDetails.classList.add("hidden");
          toggleText.textContent = "▼ 回答を確認する";
        }
      }

      // 回答詳細をレンダリング
      function renderReviewDetails() {
        const reviewDetails = document.getElementById("review-details");
        let html = "";

        answerHistory.forEach((item, index) => {
          const resultClass = item.isCorrect ? "correct" : "incorrect";
          const resultText = item.isCorrect ? "✅ 正解" : "❌ 不正解";
          const userAnswerText = item.isTimeout
            ? "（タイムアップ）"
            : `あなたの回答: ${item.userAnswer}`;

          // 形式に応じて表示を切り替え
          let questionDisplay, correctDisplay, modeIcon;

          // 混合モードの場合は問題ごとのモードを確認
          let itemMode = quizMode;
          if (quizMode === "mixed") {
            const wordProgress = progress.words[item.question.id];
            itemMode =
              wordProgress && wordProgress.mode ? wordProgress.mode : "meaning";
          }

          if (itemMode === "recall") {
            questionDisplay = `意味: ${item.question.correct}`;
            correctDisplay = `正解: ${item.question.term}`;
            modeIcon =
              quizMode === "mixed"
                ? '<span style="color: #9b59b6; font-size: 0.85rem;">🧩 想起</span> '
                : "";
          } else {
            questionDisplay = `語句: ${item.question.term}`;
            correctDisplay = `正解: ${item.question.correct}`;
            modeIcon =
              quizMode === "mixed"
                ? '<span style="color: #3498db; font-size: 0.85rem;">📖 理解</span> '
                : "";
          }

          html += `
          <div class="review-item ${resultClass}">
            <div class="review-term">
              ${modeIcon}Q${index + 1}. ${questionDisplay}
              <span class="review-result ${resultClass}">${resultText}</span>
            </div>
            ${
              !item.isCorrect
                ? `<div class="review-answer">${userAnswerText}</div>`
                : ""
            }
            <div class="review-answer" style="color: #27ae60; font-weight: bold;">${correctDisplay}</div>
            <div class="review-answer" style="font-style: italic; color: #666;">${
              item.question.example
            }</div>
          </div>
        `;
        });

        reviewDetails.innerHTML = html;
      }

      // 次の問題へ進む（手動）
      function proceedToNext() {
        // 自動遷移のタイマーをキャンセル
        clearTimeout(autoNextTimeout);
        // 即座に次の問題へ
        showNextQuestion();
      }

      // データをリセット
      function resetAllData() {
        if (
          confirm(
            "すべてのデータ（スコア、連続日数、進捗）がリセットされます。\nよろしいですか？"
          )
        ) {
          localStorage.removeItem("vocabQuizProgress");
          alert("データをリセットしました。ページを再読み込みします。");
          location.reload();
        }
      }

      // 起動時に初期化
      init();
    </script>
  </body>
</html>
